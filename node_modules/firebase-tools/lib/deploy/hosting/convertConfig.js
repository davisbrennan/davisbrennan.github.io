"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertConfig = void 0;
const error_1 = require("../../error");
const backend_1 = require("../functions/backend");
function has(obj, k) {
    return obj[k] !== undefined;
}
function extractPattern(type, spec) {
    let glob = "";
    let regex = "";
    if ("source" in spec) {
        glob = spec.source;
    }
    if ("glob" in spec) {
        glob = spec.glob;
    }
    if ("regex" in spec) {
        regex = spec.regex;
    }
    if (glob && regex) {
        throw new error_1.FirebaseError(`Cannot specify a ${type} pattern with both a glob and regex.`);
    }
    else if (glob) {
        return { glob: glob };
    }
    else if (regex) {
        return { regex: regex };
    }
    throw new error_1.FirebaseError(`Cannot specify a ${type} with no pattern (either a glob or regex required).`);
}
async function convertConfig(context, payload, config, finalize) {
    if (Array.isArray(config)) {
        throw new error_1.FirebaseError(`convertConfig should be given a single configuration, not an array.`, {
            exit: 2,
        });
    }
    const out = {};
    if (!config) {
        return out;
    }
    const endpointBeingDeployed = (serviceId, region = "us-central1") => {
        var _a;
        for (const { wantBackend } of Object.values(payload.functions || {})) {
            const endpoint = (_a = wantBackend === null || wantBackend === void 0 ? void 0 : wantBackend.endpoints[region]) === null || _a === void 0 ? void 0 : _a[serviceId];
            if (endpoint && (0, backend_1.isHttpsTriggered)(endpoint) && endpoint.platform === "gcfv2")
                return endpoint;
        }
        return undefined;
    };
    const matchingEndpoint = async (serviceId, region = "us-central1") => {
        const pendingEndpoint = endpointBeingDeployed(serviceId, region);
        if (pendingEndpoint)
            return pendingEndpoint;
        const backend = await (0, backend_1.existingBackend)(context);
        return (0, backend_1.allEndpoints)(backend).find((it) => (0, backend_1.isHttpsTriggered)(it) &&
            it.platform === "gcfv2" &&
            it.id === serviceId &&
            it.region === region);
    };
    if (Array.isArray(config.rewrites)) {
        out.rewrites = [];
        for (const rewrite of config.rewrites) {
            const vRewrite = extractPattern("rewrite", rewrite);
            if ("destination" in rewrite) {
                vRewrite.path = rewrite.destination;
            }
            else if ("function" in rewrite) {
                if (!finalize && endpointBeingDeployed(rewrite.function, rewrite.region))
                    continue;
                const endpoint = await matchingEndpoint(rewrite.function, rewrite.region);
                if (endpoint) {
                    vRewrite.run = { serviceId: endpoint.id, region: endpoint.region };
                }
                else {
                    vRewrite.function = rewrite.function;
                    if (rewrite.region) {
                        vRewrite.functionRegion = rewrite.region;
                    }
                    else {
                        vRewrite.functionRegion = "us-central1";
                    }
                }
            }
            else if ("dynamicLinks" in rewrite) {
                vRewrite.dynamicLinks = rewrite.dynamicLinks;
            }
            else if ("run" in rewrite) {
                if (!finalize && endpointBeingDeployed(rewrite.run.serviceId, rewrite.run.region))
                    continue;
                vRewrite.run = Object.assign({ region: "us-central1" }, rewrite.run);
            }
            out.rewrites.push(vRewrite);
        }
    }
    if (Array.isArray(config.redirects)) {
        out.redirects = config.redirects.map((redirect) => {
            const vRedirect = extractPattern("redirect", redirect);
            vRedirect.location = redirect.destination;
            if (redirect.type) {
                vRedirect.statusCode = redirect.type;
            }
            return vRedirect;
        });
    }
    if (Array.isArray(config.headers)) {
        out.headers = config.headers.map((header) => {
            const vHeader = extractPattern("header", header);
            vHeader.headers = {};
            if (Array.isArray(header.headers) && header.headers.length) {
                header.headers.forEach((h) => {
                    vHeader.headers[h.key] = h.value;
                });
            }
            return vHeader;
        });
    }
    if (has(config, "cleanUrls")) {
        out.cleanUrls = config.cleanUrls;
    }
    if (config.trailingSlash === true) {
        out.trailingSlashBehavior = "ADD";
    }
    else if (config.trailingSlash === false) {
        out.trailingSlashBehavior = "REMOVE";
    }
    if (has(config, "appAssociation")) {
        out.appAssociation = config.appAssociation;
    }
    if (has(config, "i18n")) {
        out.i18n = config.i18n;
    }
    return out;
}
exports.convertConfig = convertConfig;
