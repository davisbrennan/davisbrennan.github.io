"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveBackend = exports.of = exports.empty = void 0;
const backend = require("./backend");
const proto = require("../../gcp/proto");
const api = require("../../.../../api");
const error_1 = require("../../error");
const functional_1 = require("../../functional");
function empty() {
    return {
        requiredAPIs: [],
        endpoints: {},
        params: [],
    };
}
exports.empty = empty;
function of(endpoints) {
    const build = empty();
    build.endpoints = endpoints;
    return build;
}
exports.of = of;
function resolveInt(from) {
    if (from == null) {
        return 0;
    }
    else if (typeof from === "string") {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    return from;
}
function resolveString(from) {
    if (from == null) {
        return "";
    }
    else if (from.includes("{{") && from.includes("}}")) {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    return from;
}
function resolveBoolean(from) {
    if (from == null) {
        return false;
    }
    else if (typeof from === "string") {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    return from;
}
function isMemoryOption(value) {
    return value == null || [128, 256, 512, 1024, 2048, 4096, 8192].includes(value);
}
function resolveBackend(build, userEnvs) {
    for (const param of build.params) {
        const expectedEnv = param.param;
        if (!userEnvs.hasOwnProperty(expectedEnv)) {
            throw new error_1.FirebaseError("Build specified parameter " +
                expectedEnv +
                " but it was not present in the user dotenv files");
        }
    }
    const bkEndpoints = [];
    for (const endpointId of Object.keys(build.endpoints)) {
        const endpoint = build.endpoints[endpointId];
        let regions = endpoint.region;
        if (typeof regions === "undefined") {
            regions = [api.functionsDefaultRegion];
        }
        for (const region of regions) {
            const trigger = discoverTrigger(endpoint);
            if (typeof endpoint.platform === "undefined") {
                throw new error_1.FirebaseError("platform can't be undefined");
            }
            if (!isMemoryOption(endpoint.availableMemoryMb)) {
                throw new error_1.FirebaseError("available memory must be a supported value, if present");
            }
            let timeout;
            if (endpoint.timeoutSeconds) {
                timeout = resolveInt(endpoint.timeoutSeconds);
            }
            else {
                timeout = 60;
            }
            const bkEndpoint = Object.assign({ id: endpointId, project: endpoint.project, region: region, entryPoint: endpoint.entryPoint, platform: endpoint.platform, runtime: endpoint.runtime, timeoutSeconds: timeout }, trigger);
            proto.renameIfPresent(bkEndpoint, endpoint, "maxInstances", "maxInstances", resolveInt);
            proto.renameIfPresent(bkEndpoint, endpoint, "minInstances", "minInstances", resolveInt);
            proto.renameIfPresent(bkEndpoint, endpoint, "concurrency", "concurrency", resolveInt);
            proto.copyIfPresent(bkEndpoint, endpoint, "ingressSettings", "availableMemoryMb", "environmentVariables", "labels");
            if (endpoint.vpc) {
                bkEndpoint.vpc = {
                    connector: resolveString(endpoint.vpc.connector).replace("$REGION", region),
                };
                proto.copyIfPresent(bkEndpoint.vpc, endpoint.vpc, "egressSettings");
            }
            if (endpoint.serviceAccount) {
                bkEndpoint.serviceAccountEmail = endpoint.serviceAccount;
            }
            bkEndpoints.push(bkEndpoint);
        }
    }
    const bkend = backend.of(...bkEndpoints);
    bkend.requiredAPIs = build.requiredAPIs;
    return bkend;
}
exports.resolveBackend = resolveBackend;
function discoverTrigger(endpoint) {
    let trigger;
    if ("httpsTrigger" in endpoint) {
        const bkHttps = {};
        if (endpoint.httpsTrigger.invoker) {
            bkHttps.invoker = [endpoint.httpsTrigger.invoker];
        }
        trigger = { httpsTrigger: bkHttps };
    }
    else if ("callableTrigger" in endpoint) {
        trigger = { callableTrigger: {} };
    }
    else if ("blockingTrigger" in endpoint) {
        throw new error_1.FirebaseError("blocking triggers not supported");
    }
    else if ("eventTrigger" in endpoint) {
        const bkEventFilters = {};
        for (const key in endpoint.eventTrigger.eventFilters) {
            if (typeof key === "string") {
                bkEventFilters[key] = resolveString(endpoint.eventTrigger.eventFilters[key]);
            }
        }
        const bkEvent = {
            eventType: endpoint.eventTrigger.eventType,
            eventFilters: bkEventFilters,
            retry: resolveBoolean(endpoint.eventTrigger.retry),
        };
        if (endpoint.eventTrigger.serviceAccount) {
            bkEvent.serviceAccountEmail = endpoint.eventTrigger.serviceAccount;
        }
        if (endpoint.eventTrigger.region) {
            bkEvent.region = resolveString(endpoint.eventTrigger.region);
        }
        trigger = { eventTrigger: bkEvent };
    }
    else if ("scheduleTrigger" in endpoint) {
        const bkSchedule = {
            schedule: resolveString(endpoint.scheduleTrigger.schedule),
            timeZone: resolveString(endpoint.scheduleTrigger.timeZone),
        };
        proto.renameIfPresent(bkSchedule, endpoint.scheduleTrigger, "retryConfig", "retryConfig", resolveInt);
        trigger = { scheduleTrigger: bkSchedule };
    }
    else if ("taskQueueTrigger" in endpoint) {
        const bkTaskQueue = {};
        if (endpoint.taskQueueTrigger.rateLimits) {
            const bkRateLimits = {};
            proto.renameIfPresent(bkRateLimits, endpoint.taskQueueTrigger.rateLimits, "maxConcurrentDispatches", "maxConcurrentDispatches", resolveInt);
            proto.renameIfPresent(bkRateLimits, endpoint.taskQueueTrigger.rateLimits, "maxDispatchesPerSecond", "maxDispatchesPerSecond", resolveInt);
            bkTaskQueue.rateLimits = bkRateLimits;
        }
        if (endpoint.taskQueueTrigger.retryConfig) {
            const bkRetryConfig = {};
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxAttempts", "maxAttempts", resolveInt);
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxBackoffSeconds", "maxBackoffSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "minBackoffSeconds", "minBackoffSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxRetrySeconds", "maxRetryDurationSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxDoublings", "maxDoublings", resolveInt);
            bkTaskQueue.retryConfig = bkRetryConfig;
        }
        if (endpoint.taskQueueTrigger.invoker) {
            bkTaskQueue.invoker = endpoint.taskQueueTrigger.invoker.map((sa) => resolveString(sa));
        }
        trigger = { taskQueueTrigger: bkTaskQueue };
    }
    else {
        (0, functional_1.assertExhaustive)(endpoint);
    }
    return trigger;
}
